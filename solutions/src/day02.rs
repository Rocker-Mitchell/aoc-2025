use aoc_framework::{
    ParseError, ParseResult, ParsedPart1, ParsedPart2, SolutionName,
    impl_runnable_solution,
};

/// Solution for the second day's puzzle.
///
/// # Input
///
/// Input holds product ID ranges as CSV in one line. The range separates the
/// first ID and last ID w/ a dash (`-`).
///
/// # Part 1
///
/// Determine invalid IDs as a sequence of digits repeated twice; `11` from `1`,
/// `4242` from `42`, and `100100` from `100` are examples. No ID should have a
/// leading 0.
///
/// Evaluate the IDs in the range (inclusive) and sum all invalid IDs found.
///
/// # Part 2
///
/// Now invalid IDs are made of a digits sequence repeated *at least* twice. So
/// examples can be `123123123` from `123` by 3, `12121212` from `12` by 4.
///
/// Recalculate the sum of invalid IDs in ranges with the new criteria.
pub struct Day02;

impl SolutionName for Day02 {
    const NAME: &'static str = "Day 2: Gift Shop";
}

type ProductId = u64;

/// Check if the decimal representation of a product ID is a sequence of digits
/// repeated twice.
///
/// Examples of doubled sequences:
/// - `11`
/// - `4242`
/// - `100100`
fn is_doubled_sequence(value: ProductId) -> bool {
    let decimal = value.to_string();

    // odd lengths cannot form doubled sequence
    if !decimal.len().is_multiple_of(2) {
        return false;
    }

    // split the string and compare the halves
    let (left, right) = decimal.split_at(decimal.len() / 2);
    left == right
}

/// Check if the decimal representation of a product ID is a sequence of digits
/// repeating at least twice.
///
/// Examples:
/// - `11`
/// - `4242`
/// - `55555`
/// - `121212`
fn is_repeating_sequence(value: ProductId) -> bool {
    /// Recursively determine string is built as a sequence.
    /// Should fail on empty string, succeed if sequence occurs at least once.
    fn is_sequence_of(string: &str, sequence: &str) -> bool {
        // can't work with empty sequence
        if sequence.is_empty() {
            return false;
        }

        // try to slice off sequence as prefix; fail if prefix not satisfied
        string.strip_prefix(sequence).is_some_and(|remainder| {
            if remainder.is_empty() {
                // consumed string, so is a sequence
                true
            } else {
                // recursively process the remaining string
                is_sequence_of(remainder, sequence)
            }
        })
    }

    let decimal = value.to_string();

    // iterate across possible sequences by increasing length
    // - shouldn't need to iterate more than half length of string, as rest
    //   will be too short to repeat sequence
    // - skip index 0 generated by char_indices()
    let half_length = decimal.len() / 2;
    for (index, _) in decimal
        .char_indices()
        .filter(|(index, _character)| *index > 0 && *index <= half_length)
    {
        let (sequence, rest) = decimal.split_at(index);
        if is_sequence_of(rest, sequence) {
            return true;
        }
    }

    // failed to detect any repeating sequence
    false
}

impl ParsedPart1 for Day02 {
    type ParsedInput = Vec<(ProductId, ProductId)>;

    fn parse(input: &str) -> aoc_framework::ParseResult<Self::ParsedInput> {
        // need input trimmed to ignore any newline at end
        let ranges: Self::ParsedInput = input
            .trim_end()
            .split(',')
            .map(|value| {
                let mut ids = value.splitn(2, '-');

                let first_id_str = ids.next().unwrap_or("");
                let first_id =
                    first_id_str.parse::<ProductId>().map_err(|source| {
                        ParseError::parse_int_from_str(first_id_str, source)
                    })?;

                let second_id_str = ids.next().unwrap_or("");
                let second_id =
                    second_id_str.parse::<ProductId>().map_err(|source| {
                        ParseError::parse_int_from_str(second_id_str, source)
                    })?;

                Ok((first_id, second_id))
            })
            .collect::<ParseResult<_>>()?;

        if ranges.is_empty() {
            Err(ParseError::EmptyInput)
        } else {
            Ok(ranges)
        }
    }

    type Part1Output = u64;

    fn part1(ranges: &Self::ParsedInput) -> Self::Part1Output {
        let mut sum: Self::Part1Output = 0;
        for range in ranges {
            let &(left, right) = range;
            // inclusive range notation
            for id in left..=right {
                // thought to try memoization in case of overlapping ranges,
                // saw +200ms runtime on release build
                if is_doubled_sequence(id) {
                    sum += id;
                }
            }
        }
        sum
    }
}

impl ParsedPart2 for Day02 {
    type Part2Output = u64;

    fn part2(ranges: &Self::ParsedInput) -> Self::Part2Output {
        let mut sum: Self::Part2Output = 0;
        for range in ranges {
            let &(left, right) = range;
            // inclusive range notation
            for id in left..=right {
                if is_repeating_sequence(id) {
                    sum += id;
                }
            }
        }
        sum
    }
}

impl_runnable_solution!(Day02 => ParsedPart2);

#[cfg(test)]
mod tests {
    use super::*;

    const EXAMPLE_INPUT: &str = "11-22,\
        95-115,\
        998-1012,\
        1188511880-1188511890,\
        222220-222224,\
        1698522-1698528,\
        446443-446449,\
        38593856-38593862,\
        565653-565659,\
        824824821-824824827,\
        2121212118-2121212124\n";

    #[test]
    fn part1_solves_example() -> ParseResult<()> {
        let parsed = Day02::parse(EXAMPLE_INPUT)?;
        let result = Day02::part1(&parsed);
        assert_eq!(result, 1_227_775_554);
        Ok(())
    }

    #[test]
    fn is_repeating_sequence_detects_positives() {
        assert!(is_repeating_sequence(11), "false negative on 11");
        assert!(is_repeating_sequence(4242), "false negative on 4242");
        assert!(is_repeating_sequence(55555), "false negative on 55555");
        assert!(is_repeating_sequence(121_212), "false negative on 121212");
    }

    #[test]
    fn is_repeating_sequence_detects_negatives() {
        assert!(!is_repeating_sequence(123), "false positive on 123");
        assert!(!is_repeating_sequence(9998), "false positive on 9998");
        assert!(
            !is_repeating_sequence(65_465_465),
            "false positive on 65465465"
        );
    }

    #[test]
    fn part2_solves_example() -> ParseResult<()> {
        let parsed = Day02::parse(EXAMPLE_INPUT)?;
        let result = Day02::part2(&parsed);
        assert_eq!(result, 4_174_379_265);
        Ok(())
    }
}
